{"ast":null,"code":"var CombinedStream = require('combined-stream');\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar parseUrl = require('url').parse;\n\nvar fs = require('fs');\n\nvar mime = require('mime-types');\n\nvar async = require('async');\n\nmodule.exports = FormData;\n\nfunction FormData() {\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n  CombinedStream.call(this);\n}\n\nutil.inherits(FormData, CombinedStream);\nFormData.LINE_BREAK = '\\r\\n';\n\nFormData.prototype.append = function (field, value, options) {\n  options = options || {};\n  var append = CombinedStream.prototype.append.bind(this); // all that streamy business can't handle numbers\n\n  if (typeof value == 'number') value = '' + value; // https://github.com/felixge/node-form-data/issues/38\n\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n\n  var footer = this._multiPartFooter(field, value, options);\n\n  append(header);\n  append(value);\n  append(footer); // pass along options.knownLength\n\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function (header, value, options) {\n  var valueLength = 0; // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength; // @check why add CRLF? does this account for custom/multiple CRLFs?\n\n  this._overheadLength += Buffer.byteLength(header) + +FormData.LINE_BREAK.length; // empty or either doesn't have path or not an http response\n\n  if (!value || !value.path && !(value.readable && value.hasOwnProperty('httpVersion'))) {\n    return;\n  } // no need to bother with the length\n\n\n  if (!options.knownLength) this._lengthRetrievers.push(function (next) {\n    if (value.hasOwnProperty('fd')) {\n      // take read range into a account\n      // `end` = Infinity â€“> read file till the end\n      //\n      // TODO: Looks like there is bug in Node fs.createReadStream\n      // it doesn't respect `end` options without `start` options\n      // Fix it when node fixes it.\n      // https://github.com/joyent/node/issues/7819\n      if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n        // when end specified\n        // no need to calculate range\n        // inclusive, starts with 0\n        next(null, value.end + 1 - (value.start ? value.start : 0)); // not that fast snoopy\n      } else {\n        // still need to fetch file size from fs\n        fs.stat(value.path, function (err, stat) {\n          var fileSize;\n\n          if (err) {\n            next(err);\n            return;\n          } // update final size based on the range options\n\n\n          fileSize = stat.size - (value.start ? value.start : 0);\n          next(null, fileSize);\n        });\n      } // or http response\n\n    } else if (value.hasOwnProperty('httpVersion')) {\n      next(null, +value.headers['content-length']); // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty('httpModule')) {\n      // wait till response come back\n      value.on('response', function (response) {\n        value.pause();\n        next(null, +response.headers['content-length']);\n      });\n      value.resume(); // something else\n    } else {\n      next('Unknown stream');\n    }\n  });\n};\n\nFormData.prototype._multiPartHeader = function (field, value, options) {\n  var boundary = this.getBoundary();\n  var header = ''; // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n\n  if (options.header != null) {\n    header = options.header;\n  } else {\n    header += '--' + boundary + FormData.LINE_BREAK + 'Content-Disposition: form-data; name=\"' + field + '\"'; // fs- and request- streams have path property\n    // or use custom filename and/or contentType\n    // TODO: Use request's response mime-type\n\n    if (options.filename || value.path) {\n      header += '; filename=\"' + path.basename(options.filename || value.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + (options.contentType || mime.lookup(options.filename || value.path)); // http response has not\n    } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n      header += '; filename=\"' + path.basename(value.client._httpMessage.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + value.headers['content-type'];\n    }\n\n    header += FormData.LINE_BREAK + FormData.LINE_BREAK;\n  }\n\n  return header;\n};\n\nFormData.prototype._multiPartFooter = function (field, value, options) {\n  return function (next) {\n    var footer = FormData.LINE_BREAK;\n    var lastPart = this._streams.length === 0;\n\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function () {\n  return '--' + this.getBoundary() + '--';\n};\n\nFormData.prototype.getHeaders = function (userHeaders) {\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (var header in userHeaders) {\n    formHeaders[header.toLowerCase()] = userHeaders[header];\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getCustomHeaders = function (contentType) {\n  contentType = contentType ? contentType : 'multipart/form-data';\n  var formHeaders = {\n    'content-type': contentType + '; boundary=' + this.getBoundary(),\n    'content-length': this.getLengthSync()\n  };\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function () {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function () {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n}; // Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\n\n\nFormData.prototype.getLengthSync = function (debug) {\n  var knownLength = this._overheadLength + this._valueLength; // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  } // https://github.com/felixge/node-form-data/issues/40\n\n\n  if (this._lengthRetrievers.length) {\n    // Some async length retrivers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function (cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function (err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function (length) {\n      knownLength += length;\n    });\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function (params, cb) {\n  var request,\n      options,\n      defaults = {\n    method: 'post'\n  }; // parse provided url if it's string\n  // or treat it as options object\n\n  if (typeof params == 'string') {\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname\n    }, defaults);\n  } else // use custom params\n    {\n      options = populate(params, defaults); // if no port provided use default one\n\n      if (!options.port) {\n        options.port = options.protocol == 'https:' ? 443 : 80;\n      }\n    } // put that good code in getHeaders to some use\n\n\n  options.headers = this.getHeaders(params.headers); // https if specified, fallback to http in any other case\n\n  if (params.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  } // get content length and fire away\n\n\n  this.getLength(function (err, length) {\n    // TODO: Add chunked encoding when no length (if err)\n    // add content length\n    request.setHeader('Content-Length', length);\n    this.pipe(request);\n\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n  return request;\n};\n\nFormData.prototype._error = function (err) {\n  if (this.error) return;\n  this.error = err;\n  this.pause();\n  this.emit('error', err);\n};\n/*\n * Santa's little helpers\n */\n// populates missing values\n\n\nfunction populate(dst, src) {\n  for (var prop in src) {\n    if (!dst[prop]) dst[prop] = src[prop];\n  }\n\n  return dst;\n}","map":null,"metadata":{},"sourceType":"script"}