{"ast":null,"code":"/**\n * Unirest for Node.js\n *\n * @author Nijko Yonskai\n * @copyright 2013-2015\n * @license MIT\n */\n\n/**\n * Module Dependencies\n */\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nvar QueryString = require('querystring');\n\nvar FormData = require('form-data');\n\nvar Stream = require('stream');\n\nvar mime = require('mime');\n\nvar zlib = require('zlib');\n\nvar path = require('path');\n\nvar URL = require('url');\n\nvar fs = require('fs');\n/**\n * Define form mime type\n */\n\n\nmime.define({\n  'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']\n});\n/**\n * Initialize our Rest Container\n *\n * @type {Object}\n */\n\nvar Unirest = function Unirest(method, uri, headers, body, callback) {\n  var unirest = function unirest(uri, headers, body, callback) {\n    var $this = {\n      /**\n       * Stream Multipart form-data request\n       *\n       * @type {Boolean}\n       */\n      _stream: false,\n\n      /**\n       * Container to hold multipart form data for processing upon request.\n       *\n       * @type {Array}\n       * @private\n       */\n      _multipart: [],\n\n      /**\n       * Container to hold form data for processing upon request.\n       *\n       * @type {Array}\n       * @private\n       */\n      _form: [],\n\n      /**\n       * Request option container for details about the request.\n       *\n       * @type {Object}\n       */\n      options: {\n        /**\n         * Url obtained from request method arguments.\n         *\n         * @type {String}\n         */\n        url: uri,\n\n        /**\n         * Method obtained from request method arguments.\n         *\n         * @type {String}\n         */\n        method: method,\n\n        /**\n         * List of headers with case-sensitive fields.\n         *\n         * @type {Object}\n         */\n        headers: {}\n      },\n      hasHeader: function hasHeader(name) {\n        var headers;\n        var lowercaseHeaders;\n        name = name.toLowerCase();\n        headers = Object.keys($this.options.headers);\n        lowercaseHeaders = headers.map(function (header) {\n          return header.toLowerCase();\n        });\n\n        for (var i = 0; i < lowercaseHeaders.length; i++) {\n          if (lowercaseHeaders[i] === name) {\n            return headers[i];\n          }\n        }\n\n        return false;\n      },\n\n      /**\n       * Turn on multipart-form streaming\n       *\n       * @return {Object}\n       */\n      stream: function stream() {\n        $this._stream = true;\n        return this;\n      },\n\n      /**\n       * Attaches a field to the multipart-form request, with pre-processing.\n       *\n       * @param  {String} name\n       * @param  {String} value\n       * @return {Object}\n       */\n      field: function field(name, value, options) {\n        return handleField(name, value, options);\n      },\n\n      /**\n       * Attaches a file to the multipart-form request.\n       *\n       * @param  {String} name\n       * @param  {String|Object} path\n       * @return {Object}\n       */\n      attach: function attach(name, path, options) {\n        options = options || {};\n        options.attachment = true;\n        return handleField(name, path, options);\n      },\n\n      /**\n       * Attaches field to the multipart-form request, with no pre-processing.\n       *\n       * @param  {String} name\n       * @param  {String|Object} path\n       * @param  {Object} options\n       * @return {Object}\n       */\n      rawField: function rawField(name, value, options) {\n        $this._multipart.push({\n          name: name,\n          value: value,\n          options: options,\n          attachment: options.attachment || false\n        });\n      },\n\n      /**\n       * Basic Header Authentication Method\n       *\n       * Supports user being an Object to reflect Request\n       * Supports user, password to reflect SuperAgent\n       *\n       * @param  {String|Object} user\n       * @param  {String} password\n       * @param  {Boolean} sendImmediately\n       * @return {Object}\n       */\n      auth: function auth(user, password, sendImmediately) {\n        $this.options.auth = is(user).a(Object) ? user : {\n          user: user,\n          password: password,\n          sendImmediately: sendImmediately\n        };\n        return $this;\n      },\n\n      /**\n       * Sets header field to value\n       *\n       * @param  {String} field Header field\n       * @param  {String} value Header field value\n       * @return {Object}\n       */\n      header: function header(field, value) {\n        if (is(field).a(Object)) {\n          for (var key in field) {\n            if (field.hasOwnProperty(key)) {\n              $this.header(key, field[key]);\n            }\n          }\n\n          return $this;\n        }\n\n        var existingHeaderName = $this.hasHeader(field);\n        $this.options.headers[existingHeaderName || field] = value;\n        return $this;\n      },\n\n      /**\n       * Serialize value as querystring representation, and append or set on `Request.options.url`\n       *\n       * @param  {String|Object} value\n       * @return {Object}\n       */\n      query: function query(value) {\n        if (is(value).a(Object)) value = Unirest.serializers.form(value);\n        if (!value.length) return $this;\n        $this.options.url += (does($this.options.url).contain('?') ? '&' : '?') + value;\n        return $this;\n      },\n\n      /**\n       * Set _content-type_ header with type passed through `mime.lookup()` when necessary.\n       *\n       * @param  {String} type\n       * @return {Object}\n       */\n      type: function type(_type) {\n        $this.header('Content-Type', does(_type).contain('/') ? _type : mime.lookup(_type));\n        return $this;\n      },\n\n      /**\n       * Data marshalling for HTTP request body data\n       *\n       * Determines whether type is `form` or `json`.\n       * For irregular mime-types the `.type()` method is used to infer the `content-type` header.\n       *\n       * When mime-type is `application/x-www-form-urlencoded` data is appended rather than overwritten.\n       *\n       * @param  {Mixed} data\n       * @return {Object}\n       */\n      send: function send(data) {\n        var type = $this.options.headers[$this.hasHeader('content-type')];\n\n        if ((is(data).a(Object) || is(data).a(Array)) && !Buffer.isBuffer(data)) {\n          if (!type) {\n            $this.type('form');\n            type = $this.options.headers[$this.hasHeader('content-type')];\n            $this.options.body = Unirest.serializers.form(data);\n          } else if (~type.indexOf('json')) {\n            $this.options.json = true;\n\n            if ($this.options.body && is($this.options.body).a(Object)) {\n              for (var key in data) {\n                if (data.hasOwnProperty(key)) {\n                  $this.options.body[key] = data[key];\n                }\n              }\n            } else {\n              $this.options.body = data;\n            }\n          } else {\n            $this.options.body = Unirest.Request.serialize(data, type);\n          }\n        } else if (is(data).a(String)) {\n          if (!type) {\n            $this.type('form');\n            type = $this.options.headers[$this.hasHeader('content-type')];\n          }\n\n          if (type === 'application/x-www-form-urlencoded') {\n            $this.options.body = $this.options.body ? $this.options.body + '&' + data : data;\n          } else {\n            $this.options.body = ($this.options.body || '') + data;\n          }\n        } else {\n          $this.options.body = data;\n        }\n\n        return $this;\n      },\n\n      /**\n       * Takes multipart options and places them on `options.multipart` array.\n       * Transforms body when an `Object` or _content-type_ is present.\n       *\n       * Example:\n       *\n       *      Unirest.get('http://google.com').part({\n       *        'content-type': 'application/json',\n       *        body: {\n       *          phrase: 'Hello'\n       *        }\n       *      }).part({\n       *        'content-type': 'application/json',\n       *        body: {\n       *          phrase: 'World'\n       *        }\n       *      }).end(function (response) {})\n       *\n       * @param  {Object|String} options When an Object, headers should be placed directly on the object,\n       *                                 not under a child property.\n       * @return {Object}\n       */\n      part: function part(options) {\n        if (!$this._multipart) {\n          $this.options.multipart = [];\n        }\n\n        if (is(options).a(Object)) {\n          if (options['content-type']) {\n            var type = Unirest.type(options['content-type'], true);\n            if (type) options.body = Unirest.Response.parse(options.body);\n          } else {\n            if (is(options.body).a(Object)) {\n              options.body = Unirest.serializers.json(options.body);\n            }\n          }\n\n          $this.options.multipart.push(options);\n        } else {\n          $this.options.multipart.push({\n            body: options\n          });\n        }\n\n        return $this;\n      },\n\n      /**\n       * Sends HTTP Request and awaits Response finalization. Request compression and Response decompression occurs here.\n       * Upon HTTP Response post-processing occurs and invokes `callback` with a single argument, the `[Response](#response)` object.\n       *\n       * @param  {Function} callback\n       * @return {Object}\n       */\n      end: function end(callback) {\n        var Request;\n        var header;\n        var parts;\n        var form;\n\n        function handleRequestResponse(error, response, body) {\n          var result = {};\n          var status;\n          var data;\n          var type; // Handle pure error\n\n          if (error && !response) {\n            result.error = error;\n\n            if (callback) {\n              callback(result);\n            }\n\n            return;\n          } // Handle No Response...\n          // This is weird.\n\n\n          if (!response) {\n            console.log('This is odd, report this action / request to: http://github.com/mashape/unirest-nodejs');\n            result.error = {\n              message: 'No response found.'\n            };\n\n            if (callback) {\n              callback(result);\n            }\n\n            return;\n          } // Create response reference\n\n\n          result = response; // Create response status reference\n\n          status = response.statusCode; // Normalize MSIE response to HTTP 204\n\n          status = status === 1223 ? 204 : status; // Obtain status range typecode (1, 2, 3, 4, 5, etc.)\n\n          type = status / 100 | 0; // Generate sugar helper properties for status information\n\n          result.code = status;\n          result.status = status;\n          result.statusType = type;\n          result.info = type === 1;\n          result.ok = type === 2;\n          result.clientError = type === 4;\n          result.serverError = type === 5;\n          result.error = type === 4 || type === 5 ? function generateErrorMessage() {\n            var msg = 'got ' + result.status + ' response';\n            var err = new Error(msg);\n            err.status = result.status;\n            return err;\n          }() : false; // Iterate over Response Status Codes and generate more sugar\n\n          for (var name in Unirest.Response.statusCodes) {\n            result[name] = Unirest.Response.statusCodes[name] === status;\n          } // Cookie Holder\n\n\n          result.cookies = {}; // Cookie Sugar Method\n\n          result.cookie = function (name) {\n            return result.cookies[name];\n          };\n\n          function setCookie(cookie) {\n            var crumbs = Unirest.trim(cookie).split('=');\n            var key = Unirest.trim(crumbs[0]);\n            var value = Unirest.trim(crumbs.slice(1).join('='));\n\n            if (crumbs[0] && crumbs[0] !== '') {\n              result.cookies[key] = value === '' ? true : value;\n            }\n          }\n\n          if (response.cookies && is(response.cookies).a(Object) && Object.keys(response.cookies).length > 0) {\n            result.cookies = response.cookies;\n          } else {\n            // Handle cookies to be set\n            var cookies = response.headers['set-cookie'];\n\n            if (cookies && is(cookies).a(Array)) {\n              for (var index = 0; index < cookies.length; index++) {\n                var entry = cookies[index];\n\n                if (is(entry).a(String) && does(entry).contain(';')) {\n                  entry.split(';').forEach(setCookie);\n                }\n              }\n            } // Handle cookies that have been set\n\n\n            cookies = response.headers.cookie;\n\n            if (cookies && is(cookies).a(String)) {\n              cookies.split(';').forEach(setCookie);\n            }\n          } // Obtain response body\n\n\n          body = body || response.body;\n          result.raw_body = body;\n          result.headers = response.headers; // Handle Response Body\n\n          if (body) {\n            type = Unirest.type(result.headers['content-type'], true);\n            if (type) data = Unirest.Response.parse(body, type);else data = body;\n          }\n\n          result.body = data;\n          callback && callback(result);\n        }\n\n        function handleGZIPResponse(response) {\n          if (/^(deflate|gzip)$/.test(response.headers['content-encoding'])) {\n            var unzip = zlib.createUnzip();\n            var stream = new Stream();\n            var _on = response.on;\n            var decoder; // Keeping node happy\n\n            stream.req = response.req; // Make sure we emit prior to processing\n\n            unzip.on('error', function (error) {\n              // Catch the parser error when there is no content\n              if (error.errno === zlib.Z_BUF_ERROR || error.errno === zlib.Z_DATA_ERROR) {\n                stream.emit('end');\n                return;\n              }\n\n              stream.emit('error', error);\n            }); // Start the processing\n\n            response.pipe(unzip); // Ensure encoding is captured\n\n            response.setEncoding = function (type) {\n              decoder = new StringDecoder(type);\n            }; // Capture decompression and decode with captured encoding\n\n\n            unzip.on('data', function (buffer) {\n              if (!decoder) return stream.emit('data', buffer);\n              var string = decoder.write(buffer);\n              if (string.length) stream.emit('data', string);\n            }); // Emit yoself\n\n            unzip.on('end', function () {\n              stream.emit('end');\n            });\n\n            response.on = function (type, next) {\n              if (type === 'data' || type === 'end') {\n                stream.on(type, next);\n              } else if (type === 'error') {\n                _on.call(response, type, next);\n              } else {\n                _on.call(response, type, next);\n              }\n            };\n          }\n        }\n\n        function handleFormData(form) {\n          for (var i = 0; i < $this._multipart.length; i++) {\n            var item = $this._multipart[i];\n\n            if (item.attachment && is(item.value).a(String)) {\n              if (does(item.value).contain('http://') || does(item.value).contain('https://')) {\n                item.value = Unirest.request(item.value);\n              } else {\n                item.value = fs.createReadStream(path.resolve(item.value));\n              }\n            }\n\n            form.append(item.name, item.value, item.options);\n          }\n\n          return form;\n        }\n\n        if ($this._multipart.length && !$this._stream) {\n          var authn = function authn(auth) {\n            if (!auth) return null;\n            if (typeof auth === 'string') return auth;\n            if (auth.user && auth.pass) return auth.user + ':' + auth.pass;\n            return auth;\n          };\n\n          header = $this.options.headers[$this.hasHeader('content-type')];\n          parts = URL.parse($this.options.url);\n          form = new FormData();\n\n          if (header) {\n            $this.options.headers['content-type'] = header.split(';')[0] + '; boundary=' + form.getBoundary();\n          } else {\n            $this.options.headers['content-type'] = 'multipart/form-data; boundary=' + form.getBoundary();\n          }\n\n          return handleFormData(form).submit({\n            protocol: parts.protocol,\n            port: parts.port,\n            // Formdata doesn't expect port to be included with host\n            // so we use hostname rather than host\n            host: parts.hostname,\n            path: parts.path,\n            method: $this.options.method,\n            headers: $this.options.headers,\n            auth: authn($this.options.auth || parts.auth)\n          }, function (error, response) {\n            var decoder = new StringDecoder('utf8');\n\n            if (error) {\n              return handleRequestResponse(error, response);\n            }\n\n            if (!response.body) {\n              response.body = '';\n            } // Node 10+\n\n\n            response.resume(); // GZIP, Feel me?\n\n            handleGZIPResponse(response); // Fallback\n\n            response.on('data', function (chunk) {\n              if (typeof chunk === 'string') response.body += chunk;else response.body += decoder.write(chunk);\n            }); // After all, we end up here\n\n            response.on('end', function () {\n              return handleRequestResponse(error, response);\n            });\n          });\n        }\n\n        Request = Unirest.request($this.options, handleRequestResponse);\n        Request.on('response', handleGZIPResponse);\n\n        if ($this._multipart.length && $this._stream) {\n          handleFormData(Request.form());\n        }\n\n        return Request;\n      }\n      /**\n       * Alias for _.header_\n       * @type {Function}\n       */\n\n    };\n    $this.headers = $this.header;\n    /**\n     * Alias for _.header_\n     *\n     * @type {Function}\n     */\n\n    $this.set = $this.header;\n    /**\n     * Alias for _.end_\n     *\n     * @type {Function}\n     */\n\n    $this.complete = $this.end;\n    /**\n     * Aliases for _.end_\n     *\n     * @type {Object}\n     */\n\n    $this.as = {\n      json: $this.end,\n      binary: $this.end,\n      string: $this.end\n      /**\n       * Handles Multipart Field Processing\n       *\n       * @param {String} name\n       * @param {Mixed} value\n       * @param {Object} options\n       */\n\n    };\n\n    function handleField(name, value, options) {\n      var serialized;\n      var length;\n      var key;\n      var i;\n      options = options || {\n        attachment: false\n      };\n\n      if (is(name).a(Object)) {\n        for (key in name) {\n          if (name.hasOwnProperty(key)) {\n            handleField(key, name[key], options);\n          }\n        }\n      } else {\n        if (is(value).a(Array)) {\n          for (i = 0, length = value.length; i < length; i++) {\n            serialized = handleFieldValue(value[i]);\n\n            if (serialized) {\n              $this.rawField(name, serialized, options);\n            }\n          }\n        } else if (value != null) {\n          $this.rawField(name, handleFieldValue(value), options);\n        }\n      }\n\n      return $this;\n    }\n    /**\n     * Handles Multipart Value Processing\n     *\n     * @param {Mixed} value\n     */\n\n\n    function handleFieldValue(value) {\n      if (!(value instanceof Buffer || typeof value === 'string')) {\n        if (is(value).a(Object)) {\n          if (value instanceof fs.FileReadStream) {\n            return value;\n          } else {\n            return Unirest.serializers.json(value);\n          }\n        } else {\n          return value.toString();\n        }\n      } else return value;\n    }\n\n    function setupOption(name, ref) {\n      $this[name] = function (arg) {\n        $this.options[ref || name] = arg;\n        return $this;\n      };\n    } // Iterates over a list of option methods to generate the chaining\n    // style of use you see in Superagent and jQuery.\n\n\n    for (var x in Unirest.enum.options) {\n      if (Unirest.enum.options.hasOwnProperty(x)) {\n        var option = Unirest.enum.options[x];\n        var reference = null;\n\n        if (option.indexOf(':') > -1) {\n          option = option.split(':');\n          reference = option[1];\n          option = option[0];\n        }\n\n        setupOption(option, reference);\n      }\n    }\n\n    if (headers && typeof headers === 'function') {\n      callback = headers;\n      headers = null;\n    } else if (body && typeof body === 'function') {\n      callback = body;\n      body = null;\n    }\n\n    if (headers) $this.set(headers);\n    if (body) $this.send(body);\n    return callback ? $this.end(callback) : $this;\n  };\n\n  return uri ? unirest(uri, headers, body, callback) : unirest;\n};\n/**\n * Expose the underlying layer.\n */\n\n\nUnirest.request = require('request');\nUnirest.cookie = Unirest.request.cookie;\nUnirest.pipe = Unirest.request.pipe;\n/**\n * Mime-type lookup / parser.\n *\n * @param  {String} type\n * @param  {Boolean} parse Should we parse?\n * @return {String}\n */\n\nUnirest.type = function (type, parse) {\n  if (typeof type !== 'string') return false;\n  return parse ? type.split(/ *; */).shift() : Unirest.types[type] || type;\n};\n/**\n * Utility method to trim strings.\n *\n * @type {String}\n */\n\n\nUnirest.trim = ''.trim ? function (s) {\n  return s.trim();\n} : function (s) {\n  return s.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n};\n/**\n * Parser methods for different data types.\n *\n * @type {Object}\n */\n\nUnirest.parsers = {\n  string: function string(data) {\n    var obj = {};\n    var pairs = data.split('&');\n    var parts;\n    var pair;\n\n    for (var i = 0, len = pairs.length; i < len; ++i) {\n      pair = pairs[i];\n      parts = pair.split('=');\n      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n    }\n\n    return obj;\n  },\n  json: function json(data) {\n    try {\n      data = JSON.parse(data);\n    } catch (e) {}\n\n    return data;\n  }\n  /**\n   * Serialization methods for different data types.\n   *\n   * @type {Object}\n   */\n\n};\nUnirest.serializers = {\n  form: function form(obj) {\n    return QueryString.stringify(obj);\n  },\n  json: function json(obj) {\n    return JSON.stringify(obj);\n  }\n  /**\n   * Unirest Request Utility Methods\n   *\n   * @type {Object}\n   */\n\n};\nUnirest.Request = {\n  serialize: function serialize(string, type) {\n    var serializer = Unirest.firstMatch(type, Unirest.enum.serialize);\n    return serializer ? serializer(string) : string;\n  },\n  uid: function uid(len) {\n    var output = '';\n    var chars = 'abcdefghijklmnopqrstuvwxyz123456789';\n    var nchars = chars.length;\n\n    while (len--) {\n      output += chars[Math.random() * nchars | 0];\n    }\n\n    return output;\n  }\n  /**\n   * Unirest Response Utility Methods\n   *\n   * @type {Object}\n   */\n\n};\nUnirest.Response = {\n  parse: function parse(string, type) {\n    var parser = Unirest.firstMatch(type, Unirest.enum.parse);\n    return parser ? parser(string) : string;\n  },\n  parseHeader: function parseHeader(str) {\n    var lines = str.split(/\\r?\\n/);\n    var fields = {};\n    var index;\n    var line;\n    var field;\n    var val; // Trailing CRLF\n\n    lines.pop();\n\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i];\n      index = line.indexOf(':');\n      field = line.slice(0, index).toLowerCase();\n      val = Unirest.trim(line.slice(index + 1));\n      fields[field] = val;\n    }\n\n    return fields;\n  },\n  statusCodes: {\n    'created': 201,\n    'accepted': 202,\n    'nonAuthoritativeInformation': 203,\n    'noContent': 204,\n    'resetContent': 205,\n    'partialContent': 206,\n    'multiStatus': 207,\n    'alreadyReported': 208,\n    'imUsed': 226,\n    'multipleChoices': 300,\n    'movedPermanently': 301,\n    'found': 302,\n    'seeOther': 303,\n    'notModified': 304,\n    'useProxy': 305,\n    'temporaryRedirect': 307,\n    'permanentRedirect': 308,\n    'badRequest': 400,\n    'unauthorized': 401,\n    'paymentRequired': 402,\n    'forbidden': 403,\n    'notFound': 404,\n    'methodNotAllowed': 405,\n    'notAcceptable': 406,\n    'proxyAuthenticationRequired': 407,\n    'requestTimeout': 408,\n    'conflict': 409,\n    'gone': 410,\n    'lengthRequired': 411,\n    'preconditionFailed': 412,\n    'requestEntityTooLarge': 413,\n    'uriTooLong': 414,\n    'unsupportedMediaType': 415,\n    'rangeNotSatisfiable': 416,\n    'expectationFailed': 417,\n    'misdirectedRequest': 421,\n    'unprocessableEntity': 422,\n    'locked': 423,\n    'failedDependency': 424,\n    'upgradeRequired': 426,\n    'preconditionRequired': 428,\n    'tooManyRequests': 429,\n    'requestHeaderFieldsTooLarge': 431,\n    'internalServerError': 500,\n    'notImplemented': 501,\n    'badGateway': 502,\n    'serviceUnavailable': 503,\n    'gatewayTimeout': 504,\n    'httpVersionNotSupported': 505,\n    'variantAlsoNegotiates': 506,\n    'insufficientStorage': 507,\n    'loopDetected': 508,\n    'notExtended': 510\n  }\n  /**\n   * Expose cookie store (tough-cookie)\n   *\n   * @return {Function} Cookie Store\n   */\n\n};\n\nUnirest.jar = function (options) {\n  var jar = Unirest.request.jar();\n  options = options || {}; // Because Requests aliases toughcookie rather than returning.\n\n  if (options.store) {\n    jar._jar.store = options.store;\n  }\n\n  if (options.rejectPublicSuffixes) {\n    jar._jar.rejectPublicSuffixes = options.rejectPublicSuffixes;\n  } // Alias helper methods\n\n\n  jar.add = jar.setCookie;\n  jar.toString = jar.getCookieString; // Export\n\n  return jar;\n};\n/**\n * Enum Structures\n *\n * @type {Object}\n */\n\n\nUnirest.enum = {\n  serialize: {\n    'application/x-www-form-urlencoded': Unirest.serializers.form,\n    'application/json': Unirest.serializers.json,\n    '+json': Unirest.serializers.json\n  },\n  parse: {\n    'application/x-www-form-urlencoded': Unirest.parsers.string,\n    'application/json': Unirest.parsers.json,\n    '+json': Unirest.parsers.json\n  },\n  methods: ['GET', 'HEAD', 'PUT', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],\n  options: ['uri:url', 'redirects:maxRedirects', 'redirect:followRedirect', 'url', 'method', 'qs', 'form', 'json', 'multipart', 'followRedirect', 'followAllRedirects', 'maxRedirects', 'encoding', 'pool', 'timeout', 'proxy', 'oauth', 'hawk', 'time', 'ssl:strictSSL', 'strictSSL', 'jar', 'cookies:jar', 'aws', 'httpSignature', 'localAddress', 'ip:localAddress', 'secureProtocol', 'forever']\n  /**\n   * Returns a list of values obtained by checking the specified string\n   * whether it contains array value or object key, when true the value\n   * is appended to the list to be returned.\n   *\n   * @param  {String} string String to be tested\n   * @param  {Object|Array} map    Values / Keys to test against string.\n   * @return {Array} List of values truthfully matched against string.\n   */\n\n};\n\nUnirest.matches = function matches(string, map) {\n  var results = [];\n\n  for (var key in map) {\n    if (typeof map.length !== 'undefined') {\n      key = map[key];\n    }\n\n    if (string.indexOf(key) !== -1) {\n      results.push(map[key]);\n    }\n  }\n\n  return results;\n};\n/**\n * Returns the first value obtained through #matches\n *\n * @see #matches\n * @param  {String} string String to be tested\n * @param  {Object|Array} map Values / Keys to test against string.\n * @return {Mixed} First match value\n */\n\n\nUnirest.firstMatch = function firstMatch(string, map) {\n  return Unirest.matches(string, map)[0];\n};\n/**\n * Generate sugar for request library.\n *\n * This allows us to mock super-agent chaining style while using request library under the hood.\n */\n\n\nfunction setupMethod(method) {\n  Unirest[method] = Unirest(method);\n}\n\nfor (var i = 0; i < Unirest.enum.methods.length; i++) {\n  var method = Unirest.enum.methods[i].toLowerCase();\n  setupMethod(method);\n}\n/**\n * Simple Utility Methods for checking information about a value.\n *\n * @param  {Mixed}  value  Could be anything.\n * @return {Object}\n */\n\n\nfunction is(value) {\n  return {\n    a: function a(check) {\n      if (check.prototype) check = check.prototype.constructor.name;\n      var type = Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\n      return value != null && type === check.toLowerCase();\n    }\n  };\n}\n/**\n * Simple Utility Methods for checking information about a value.\n *\n * @param  {Mixed}  value  Could be anything.\n * @return {Object}\n */\n\n\nfunction does(value) {\n  var arrayIndexOf = Array.indexOf ? function (arr, obj, from) {\n    return arr.indexOf(obj, from);\n  } : function (arr, obj, from) {\n    var l = arr.length;\n    var i = from ? parseInt(1 * from + (from < 0 ? l : 0), 10) : 0;\n    i = i < 0 ? 0 : i;\n\n    for (; i < l; i++) {\n      if (i in arr && arr[i] === obj) return i;\n    }\n\n    return -1;\n  };\n  return {\n    startWith: function startWith(string) {\n      if (is(value).a(String)) return value.slice(0, string.length) === string;\n      if (is(value).a(Array)) return value[0] === string;\n      return false;\n    },\n    endWith: function endWith(string) {\n      if (is(value).a(String)) return value.slice(-string.length) === string;\n      if (is(value).a(Array)) return value[value.length - 1] === string;\n      return false;\n    },\n    contain: function contain(field) {\n      if (is(value).a(String)) return value.indexOf(field) > -1;\n      if (is(value).a(Object)) return value.hasOwnProperty(field);\n      if (is(value).a(Array)) return !!~arrayIndexOf(value, field);\n      return false;\n    }\n  };\n}\n/**\n * Expose the Unirest Container\n */\n\n\nmodule.exports = exports = Unirest;","map":null,"metadata":{},"sourceType":"script"}